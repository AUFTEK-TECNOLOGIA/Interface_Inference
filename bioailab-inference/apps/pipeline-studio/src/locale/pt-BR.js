export const ptBR = {
  common: {
    all: "Todos",
    channels: "Canais",
  },
  nodeCategories: {
    data: "Dados",
    process: "Processo",
    analysis: "Análise",
    ml: "ML",
    flow: "Fluxo",
    block: "Bloco",
  },
  app: {
    title: "Auftek Studio",
    subtitle: "Construa e organize fluxos de análise de forma visual",
    pipelineNamePlaceholder: "Nome do fluxo",
    loadTitle: "Importar fluxo (arquivo)",
    saveTitle: "Salvar",
  },
  workspace: {
    kicker: "Início",
    title: "Selecione um cliente",
    subtitle: "Crie um novo cliente ou abra um fluxo existente.",
    open: "Início",
    openTitle: "Abrir tela inicial",
    current: "Cliente: {tenant}",
    currentVersion: "Versão: {version}",
    download: "Exportar",
    downloadTitle: "Baixar o arquivo JSON do fluxo",
    createTitle: "Novo cliente",
    tenantLabel: "Cliente",
    pipelineIdLabel: "Fluxo",
    tenantPlaceholder: "Ex: aufteksm",
    tenantHint: "Este é o identificador do cliente (usado para salvar e carregar).",
    create: "Criar",
    creating: "Criando...",
    createPathHint: "Você poderá personalizar o nome e o logo depois.",
    createClientCta: "Criar novo cliente",
    backToAvailable: "Voltar para fluxos disponíveis",
    loadTitle: "Fluxos disponíveis",
    pipelineLabel: "Fluxos disponíveis",
    availableSubtitle: "Selecione um fluxo para abrir no editor.",
    createSubtitle: "Preencha os dados para criar um novo cliente.",
    selectPlaceholder: "Selecione um cliente",
    loadingList: "Carregando...",
    loadHint: "Abre o fluxo selecionado no editor.",
    load: "Abrir",
    loading: "Carregando...",
    refresh: "Atualizar lista",
    loadFromFile: "Importar de um arquivo (JSON)",
    pickHint: "Clique em um card para selecionar.",
    appearanceTitle: "Personalização",
    appearanceHint: "Essas informações são usadas apenas para exibição.",
    logoLocalLabel: "Logo do cliente",
    chooseLogo: "Escolher arquivo",
    logoSelectedHint: "Logo selecionado",
    uploadingLogo: "Enviando...",
    titleLabel: "Nome exibido",
    saveAppearance: "Salvar",
    savingAppearance: "Salvando...",
    editAction: "Editar",
    versionsAction: "Versões",
    versionsLabel: "versões",
    versionsTitle: "Versões do fluxo",
    versionsHint: "A versão ativa é usada quando o fluxo é executado pela API.",
    changeReasonLabel: "Razão (opcional)",
    changeReasonPlaceholder: "Ex: Ajuste de parâmetros para um novo cenário",
    loadingVersions: "Carregando versões...",
    activeVersionLabel: "Ativa",
    inactiveVersionLabel: "Inativa",
    basedOnLabel: "base",
    versionCreatedAt: "Criada em {date}",
    versionUpdatedAt: "Atualizada em {date}",
    versionHistoryTitle: "Histórico de modificações",
    searchVersionsLabel: "Buscar",
    searchVersionsPlaceholder: "Buscar por nome ou ID",
    versionsShowing: "Mostrando {start}–{end} de {total}",
    activeVersionShort: "Ativa: {id}",
    showVersionDetails: "Detalhes",
    hideVersionDetails: "Ocultar",
    versionLastChangeLabel: "Última alteração: {date}",
    openVersionAction: "Abrir",
    openVersionLogsAction: "Histórico",
    versionActionsTitle: "Ações da versão",
    versionActionsViewTitle: "Visualização",
    versionActionsEditTitle: "Edição",
    versionActionsActivationTitle: "Ativação",
    versionActionsDangerTitle: "Remoção",
    versionLogsTitle: "Histórico da versão",
    searchLogsLabel: "Buscar no histórico",
    searchLogsPlaceholder: "Buscar por texto ou ação",
    noLogs: "Nenhum registro encontrado.",
    paginationLabel: "Paginação de versões",
    paginationPrev: "Anteriores",
    paginationNext: "Próximas",
    paginationMeta: "Página {page} de {total}",
    activateVersionAction: "Ativar",
    renameVersionAction: "Renomear",
    renameVersionTitle: "Renomear versão",
    versionNameLabel: "Nome da versão",
    versionNamePlaceholder: "Ex: Produção (v2)",
    saveVersionNameAction: "Salvar nome",
    savingVersionName: "Salvando...",
    createVersionAction: "Nova versão",
    creatingVersion: "Criando versão...",
    createVersionCopyAction: "Nova versão (cópia)",
    createVersionCleanAction: "Nova versão",
    copyVersionAction: "Copiar",
    deleteVersionTitle: "Excluir versão",
    deleteVersionConfirm: "Esta ação não pode ser desfeita. A versão será removida permanentemente.",
    deleteVersionAction: "Excluir",
    deletingVersion: "Excluindo...",
    duplicateTitle: "Duplicar para um novo cliente",
    duplicateTenantLabel: "Nome do novo cliente",
    duplicateTenantPlaceholder: "Ex: cliente_novo",
    duplicateAction: "Duplicar",
    duplicating: "Duplicando...",
    deleteTitle: "Excluir fluxo",
    deleteConfirm: "Esta ação não pode ser desfeita. O fluxo será removido permanentemente.",
    deleteAction: "Excluir",
    deleting: "Excluindo...",
    cardMenuLabel: "Ações do cliente",
  },
  panels: {
    blocks: "Blocos",
    summary: "Resumo",
    configuration: "Configuração",
    results: "Resultados",
  },
  helper: {
    openLabel: "Abrir ajuda do bloco",
    title: "Resumo do bloco",
    tabs: {
      overview: "Visao geral",
      io: "Entradas e saidas",
      config: "Configuracao",
      examples: "Exemplos",
      troubleshooting: "Erros comuns",
    },
    sections: {
      what: "O que faz",
      when: "Quando usar",
      how: "Como funciona",
      tips: "Dicas",
      inputs: "Entradas",
      outputs: "Saidas",
      configs: "Configuracoes",
      examples: "Exemplos",
      errors: "Erros comuns",
    },
  },
  blockResults: {
    openLabel: "Ver resultados deste bloco",
    title: "Resultados do bloco",
    noSimulation: "Execute uma simulação para ver os resultados deste bloco.",
    noResults: "Não há resultados disponíveis para este bloco nesta simulação.",
  },
  actions: {
    load: "Carregar",
    save: "Salvar",
    add: "Adicionar",
    simulate: "Simular",
    simulating: "Simulando...",
    train: "Treinar",
    training: "Treinando...",
    viewResults: "Resultados",
    deleteBlock: "Excluir bloco",
    deleteSelection: "Excluir selecao ({count})",
    remove: "Remover",
    removeConnection: "Remover conexão",
    reconnectHint: "Arraste as pontas da conexão para reconectar",
    deleteKeyHint: "para remover",
    close: "Fechar",
    clear: "Limpar",
    selectAll: "Selecionar tudo",
    autoLayout: "Organizar",
    autoLayoutTitle: "Organizar automaticamente",
    pin: "Fixar",
    unpin: "Desafixar",
    previous: "Anterior",
    next: "Próximo",
    cancel: "Cancelar",
    delete: "Excluir",
    more: "Mais opções",
  },
  training: {
    title: "Treinamento de modelos",
    subtitle: "Use resultados de laboratório para treinar os blocos de ML do fluxo.",
    back: "Voltar",
    next: "Próximo",
    configureBlock: "Configurar",
    validation: {
      data: "Preencha o analysisId e informe ao menos um experimentId.",
      models: "Selecione ao menos um bloco de ML para treinar.",
      params: "Revise os parâmetros do treinamento.",
      gridSearchManualSingleModel: "O modo de seleção manual suporta apenas um modelo por vez. Desative o modo ou selecione apenas um bloco de ML.",
    },
    steps: {
      label: "Etapas do treinamento",
      data: "Dados",
      dataDesc: "Escolha o alvo e os experimentos",
      models: "Modelos",
      modelsDesc: "Selecione os blocos e ajuste o algoritmo",
      review: "Revisão",
      reviewDesc: "Confirme e inicie o treinamento",
    },
    review: {
      analysisId: "Analysis ID",
      experiments: "Experimentos",
      models: "Blocos ativos",
      transform: "Transformação do y",
    },
    advanced: {
      title: "Configurações avançadas",
      show: "Mostrar avançado",
      hide: "Ocultar avançado",
      summary: "Métrica: {metric} • Máx. tentativas: {trials} • Validação: {testSize}",
      selectionMetric: "Métrica de seleção (grid search)",
      selectionMetricHint: "Define como escolher o melhor modelo na varredura.",
      maxTrials: "Limite de tentativas (max_trials)",
      maxTrialsHint: "Evita varreduras muito longas por bloco.",
      testSize: "Validação (test_size)",
      testSizeHint: "0 = treina com todos os dados (sem validação).",
      randomState: "Seed (random_state)",
      randomStateHint: "Mantém o split e o treino reprodutíveis.",
      permImportance: "Calcular importância por permutação (validação)",
      permRepeats: "Repetições (perm_repeats)",
      permRepeatsHint: "Mais repetições = mais estável, porém mais lento.",
    },
    grid: {
      enable: "Ativar varredura (grid search)",
      on: "Grid: ligado",
      off: "Grid: desligado",
      algorithms: "Algoritmos",
      gridLabel: "Grade de parâmetros (JSON)",
      gridHint: "Ex: {\"alpha\":[0.1,1,10], \"n_estimators\":[200,400]}",
    },
    presets: {
      title: "Parâmetros do modelo",
      helper: "Use os campos abaixo para configurar sem escrever JSON. O JSON continua disponível em Avançado.",
      defaults: "Aplicar padrão",
      clear: "Limpar",
      gridTitle: "Grade de parâmetros (grid search)",
      gridHelper: "Sugestão de grade por algoritmo. Ajuste conforme seu volume de dados.",
      applyGridDefaults: "Aplicar grade sugerida",
    },
    sections: {
      data: "Dados do treinamento",
      models: "Modelos",
    },
    metrics: {
      experiments: "{count} experimentos",
      models: "{enabled} de {total} modelos",
    },
    protocolIdLabel: "Protocol ID",
    protocolIdPlaceholder: "Ex: 68cb3fb380ac865ce0647ea8",
    experimentIdsLabel: "Experimentos para treino",
    experimentIdsHint: "Cole uma lista de experimentId (um por linha ou separado por vírgula).",
    manualIdsToggle: "Ou cole os IDs manualmente",
    yTransformLabel: "Transformação do alvo (y)",
    yTransformNone: "Sem transformação",
    yTransformLog10p: "log10(y + 1)",
    blocksTitle: "Blocos de ML para treinar",
    emptyModels: "Nenhum bloco de ML encontrado no canvas.",
    blockEnabled: "Ativar",
    algorithmLabel: "Algoritmo",
    paramsLabel: "Parâmetros (JSON)",
    paramsPlaceholder: "Ex: {\"alpha\": 1.0}",
    applyToPipelineLabel: "Atualizar o fluxo e criar uma nova versão ativa",
    applyToPipelineOn: "Criar versão e ativar",
    applyToPipelineOff: "Apenas treinar (não altera o fluxo)",
    gridSearchManualLabel: "Modo seleção manual",
    gridSearchManualOn: "Salvar todos os candidatos",
    gridSearchManualOff: "Aplicar automaticamente o melhor",
    gridSearchManualHint: "Quando ativo, todos os modelos candidatos do grid search são salvos e você pode escolher qual usar depois.",
    changeReasonLabel: "Razão (opcional)",
    changeReasonPlaceholder: "Ex: Treino com novos experimentos do mês",
    showAdvanced: "Configurações avançadas",
    hideAdvanced: "Ocultar avançado",
    run: "Iniciar treinamento",
    running: "Treinando...",
    resultTitle: "Resultado do treinamento",
    versionActivated: "Versão ativada: {version}",
    trainedCount: "Treinados: {count}",
    skippedCount: "Experimentos ignorados: {count}",
    skippedModelsCount: "Pulados: {count}",
    errorsCount: "Erros: {count}",
    errorsTitle: "Erros do treinamento",
    trainedModels: "Modelos treinados",
    skippedModels: "Modelos pulados (sem dados)",
    viewCandidates: "Visualizar candidatos",
    algorithmsLabel: "Algoritmos",
    blockConfig: {
      title: "Configuração do modelo",
      subtitle: "Selecione um ou mais algoritmos e ajuste os parâmetros. A seleção escolhe automaticamente o melhor.",
      algorithmsHint: "Dica: selecione mais de um algoritmo para comparar (ex: Ridge + Random Forest).",
      activeAlgorithm: "Editando",
      resetDefaults: "Restaurar padrão",
      searchTitle: "Seleção e limites",
      searchSubtitle: "Define a métrica de seleção e o limite de tentativas por bloco.",
    },
    forecaster: {
      blockTitle: "Configuração do forecaster",
      blockSubtitle: "A série (janela, horizonte e canais) vem do bloco no diagrama. Aqui você escolhe o regressor e seus parâmetros.",
      seriesConfigTitle: "Série temporal",
      targetChannel: "Canal alvo (target_channel)",
      targetChannelPlaceholder: "Ex: turbidimetry:f1 ou f1",
      targetChannelHint: "Se houver mais de um sensor com o mesmo canal (ex: f1), use o nome completo com prefixo.",
      window: "Janela (window)",
      horizon: "Horizonte (horizon)",
      inputChannels: "Canais de entrada (opcional)",
      inputChannelsPlaceholder: "Vazio = automático (recomendado)",
      inputChannelsHint: "Use nomes separados por vírgula. Se o sensor_data veio do Combinar sensores, os canais ficam no formato 'prefixo:canal'.",
      maxSamples: "Máx. amostras por experimento (max_samples)",
      regressorLabel: "Regressor (algoritmos)",
    },
    paramsTable: {
      aria: "Tabela de parâmetros do modelo",
      param: "Parâmetro",
      mode: "Modo",
      fixed: "Fixo",
      grid: "Grade",
      value: "Valor",
      min: "Mín.",
      max: "Máx.",
      divisions: "Divisões",
      nullLabel: "Sem limite",
    },
  },
  candidates: {
    title: "Candidatos do Grid Search",
    subtitle: "Selecione o modelo que deseja usar no pipeline",
    loading: "Carregando candidatos...",
    error: "Erro ao carregar candidatos",
    noData: "Nenhum candidato encontrado",
    table: {
      rank: "Pos.",
      algorithm: "Algoritmo",
      params: "Parâmetros",
      score: "Score",
      actions: "Ações",
    },
    metrics: {
      title: "Métricas de Validação",
      val_rmse: "RMSE (val)",
      val_mae: "MAE (val)",
      val_r2: "R² (val)",
      train_rmse: "RMSE (train)",
      train_mae: "MAE (train)",
      train_r2: "R² (train)",
    },
    charts: {
      title: "Gráficos de Desempenho",
      predictedVsActual: "Predito vs Real",
      residuals: "Resíduos",
      train: "Treino",
      validation: "Validação",
    },
    actions: {
      select: "Usar este modelo",
      selected: "Modelo selecionado",
      apply: "Aplicar no pipeline",
      applying: "Aplicando...",
      close: "Fechar",
      back: "Voltar",
    },
    badges: {
      best: "Melhor",
    },
  },
  datasets: {
    title: "Seleção de Experimentos",
    subtitle: "Protocolo: {protocolId}",
    tabs: {
      select: "Selecionar",
      saved: "Salvos",
      save: "Salvar Dataset",
    },
    stats: {
      total: "{count} experimentos",
      withLab: "{count} com lab",
      selected: "{count} selecionados",
    },
    searchPlaceholder: "Buscar experimento...",
    filterLabOnly: "Apenas com lab_results",
    selectAll: "Selecionar todos",
    clearSelection: "Limpar seleção",
    loading: "Carregando...",
    noExperiments: "Nenhum experimento encontrado para este protocolId",
    noMatch: "Nenhum experimento corresponde à busca",
    noSaved: "Nenhum dataset salvo. Selecione experimentos e salve como dataset.",
    hasLabResults: "Este experimento possui resultados de laboratório",
    load: "Carregar",
    createSummary: "{count} experimentos selecionados",
    nameLabel: "Nome do dataset",
    namePlaceholder: "Ex: Dataset coliformes janeiro",
    descriptionLabel: "Descrição (opcional)",
    descriptionPlaceholder: "Descreva o objetivo deste dataset...",
    saving: "Salvando...",
    saveDataset: "Salvar Dataset",
    applySelection: "Usar {count} experimentos",
    confirmDelete: "Tem certeza que deseja excluir este dataset?",
    error: {
      loadExperiments: "Erro ao carregar experimentos",
      save: "Erro ao salvar dataset",
      load: "Erro ao carregar dataset",
      delete: "Erro ao excluir dataset",
    },
    openSelector: "Selecionar experimentos",
    selectedCount: "{count} experimentos selecionados",
  },
  blocksPanel: {
    searchPlaceholder: "Buscar blocos (nome, descricao ou identificador)",
    favorites: "Fixados",
    recents: "Recentes",
    hint: "Clique para ver detalhes. Dê um duplo clique para adicionar.",
    stages: {
      routing: "Roteamento (Fluxo)",
      transformations: "Transformacoes",
      detection: "Deteccao",
      features: "Features",
      response: "Resposta / Saidas",
      acquisition: "Aquisição",
      sensorExtraction: "Extração de sensores",
      preparation: "Pre-processamento",
      processing: "Processamento",
      modelling: "Modelagem",
      analysis: "Análise",
      classification: "Predição e resposta",
      export: "Exportação",
      controlFlow: "Controle de fluxo",
    },
  },
  summary: {
    dataInputs: "Entradas de dados",
    configInputs: "Configurações",
    dataOutputs: "Saídas de dados",
    none: "Nenhuma",
    noneInput: "Nenhuma entrada",
    noneConfig: "Nenhuma configuração",
    noneOutput: "Nenhuma saída",
    availableFilters: "Filtros disponíveis",
    availableModels: "Modelos disponíveis",
    availableExtractors: "Extratores disponíveis",
    componentHint: "Clique para adicionar com este item",
    empty: "Selecione um bloco para ver os detalhes",
  },
  canvas: {
    selection: "{count} bloco selecionado",
    selectionPlural: "{count} blocos selecionados",
  },
  help: {
    templates: {
      extraction: {
        what: "Extrai uma serie temporal do experimento para um sensor especifico.",
        how: "Conecte a saida do experimento e use a saida do sensor nos proximos blocos.",
      },
      filter: {
        what: "Aplica um filtro de suavizacao/limpeza no sinal.",
        tips: "Use filtros depois de Selecionar janela e Remover outliers, quando fizer sentido.",
      },
      conversion: {
        what: "Converte os canais para outro espaco de cor.",
        tips: "Use quando o seu pipeline espera canais RGB/HSV/LAB etc.",
      },
    },
    blocks: {
      experiment_fetch: {
        what: "Carrega um experimento e disponibiliza os dados brutos e metadados para o pipeline.",
        when: [
          "Inicio do pipeline (fonte de dados).",
          "Quando voce precisa de experiment_data, analysisId e graficos de debug.",
        ],
        how: [
          "Preencha experimentId, analysisId e tenant (ou use modo demonstracao).",
          "Conecte experiment_data na etapa de sensores ou marcadores de fluxo.",
        ],
        tips: ["Ative debug/graficos apenas quando precisar investigar o sinal."],
      },
      label: {
        what: "Marca o fluxo com uma tag (label) para organizar visualmente e agrupar resultados.",
        when: [
          "Quando voce quer separar fluxos (ex: coliformes, e_coli) a partir do mesmo experimento.",
          "Antes da etapa de sensores para propagar a tag pelo restante do fluxo.",
        ],
        how: [
          "Conecte experiment_data na entrada do bloco.",
          "Defina o identificador (tag) e, se desejar, uma cor.",
          "Continue o fluxo normalmente; a tag sera propagada.",
        ],
      },
      value_in_list: {
        what: "Gera uma condicao booleana ao verificar se um valor pertence a uma lista (IN/NOT IN).",
        when: [
          "Para rotear fluxos por analysisId (ou outro identificador).",
          "Para ativar/desativar um caminho antes de processar o sinal.",
        ],
        how: [
          "Conecte o valor (ex: analysisId) na entrada value.",
          "Configure allowed_values e, se necessario, invert/case_sensitive/trim.",
          "Conecte a saida condition em Ramificacao condicional ou Portao condicional.",
        ],
      },
      condition_gate: {
        what: "Ativa ou desativa a passagem de dados com base em uma condicao booleana.",
        when: [
          "Para impedir que um caminho processe dados quando a condicao for falsa.",
          "Quando voce quer evitar executar blocos desnecessarios em um fluxo.",
        ],
        how: [
          "Conecte data e condition.",
          "Se a condicao for falsa, o bloco retorna uma saida inativa (_inactive).",
        ],
      },
      condition_branch: {
        what: "Divide o fluxo em dois caminhos: verdadeiro e falso.",
        when: [
          "Quando voce precisa de dois caminhos distintos a partir da mesma entrada.",
          "Para ramificar por analysisId, presenca, crescimento, etc.",
        ],
        how: [
          "Conecte data e condition.",
          "Use data_if_true e data_if_false nos dois ramos.",
          "Depois, use Resolver fluxo ativo para voltar a um caminho unico.",
        ],
      },
      merge: {
        what: "Resolve qual fluxo esta ativo (A ou B) e propaga somente o ativo.",
        when: [
          "Depois de uma Ramificacao condicional para voltar a um unico caminho.",
          "Para garantir que dados inativos nao avancem no pipeline.",
        ],
        how: [
          "Conecte data_if_true em data_a e data_if_false em data_b (ou vice-versa).",
          "A saida data segue adiante para o restante do fluxo.",
        ],
      },
      time_slice: {
        what: "Seleciona uma janela do sinal (por tempo ou por indice), removendo inicio e/ou fim.",
        when: [
          "Quando voce quer ignorar aquecimento inicial, estabilizacao ou ruido final.",
          "Antes de filtros, derivada e deteccao.",
        ],
        how: [
          "Conecte sensor_data do sensor.",
          "Escolha slice_mode (time/index) e defina inicio/fim.",
          "Use sensor_data na sequencia do pipeline.",
        ],
      },
      sensor_fusion: {
        what: "Combina múltiplos sensor_data (sensores diferentes) em um único sensor_data, alinhando no tempo e unificando canais.",
        when: [
          "Quando você quer usar mais de um sensor (ex: turbidimetria + nefelometria + fluorescência) no mesmo modelo.",
          "Quando precisa escolher exatamente quais canais entram no modelo, por sensor.",
        ],
        how: [
          "Conecte cada sensor na entrada sensor_data_1..N.",
          "Defina um prefixo por entrada para evitar colisões (ex: turb, neph, fluor).",
          "Informe os canais (ou deixe vazio para usar todos os canais disponíveis daquela entrada).",
          "Escolha o modo de alinhamento (interseção ou união) e, se necessário, um passo de reamostragem.",
        ],
        tips: [
          "Use prefixos sempre que houver canais repetidos (ex: f1 existe em mais de um sensor).",
          "Se o seu modelo foi treinado com um grid fixo de tempo, configure resample_step.",
        ],
      },
      ml_forecaster_series: {
        what: "Prevê (forecast) uma série temporal a partir de uma janela do próprio sinal, gerando um novo canal no sensor_data.",
        when: [
          "Quando você quer transformar um sinal em uma versão prevista/tratada antes de extrair features ou fazer inferência.",
          "Quando deseja treinar um modelo que aprende padrão temporal do sensor (sem precisar de alvo de laboratório).",
        ],
        how: [
          "Conecte um sensor_data (ou a saída do Combinar sensores) na entrada.",
          "Treine pelo botão Treinar; o pipeline cria e salva o modelo do forecaster automaticamente.",
          "Na execução, o bloco adiciona um canal previsto (ex: 'turb:forecast_f1' ou 'forecast_f1').",
        ],
        tips: [
          "Se o sensor_data veio do Combinar sensores, os canais ficam prefixados (ex: 'turbidimetry:f1').",
          "Se você não configurar input_channels, o bloco tenta usar automaticamente os canais do mesmo sensor do target_channel.",
          "Se você configurar target_channel como 'f1' e houver mais de um sensor com 'f1', use o nome completo (ex: 'turbidimetry:f1').",
        ],
      },
      outlier_removal: {
        what: "Remove outliers do sinal usando metodos como zscore, iqr ou mad.",
        when: [
          "Quando o sensor tem picos/ruidos que atrapalham filtros, derivada ou deteccao.",
          "Antes de filtros e antes de detectores/feature extraction.",
        ],
        how: [
          "Conecte sensor_data.",
          "Escolha method e threshold.",
          "Use o sensor_data de saida nos proximos blocos.",
        ],
      },
      amplitude_detector: {
        what: "Detecta crescimento no sinal com base na amplitude e retorna has_growth.",
        when: [
          "Quando voce precisa saber se houve crescimento antes de predizer/retornar resultado.",
          "Para acionar ramificacoes condicionais por presenca/ausencia.",
        ],
        how: ["Conecte sensor_data e use has_growth (booleano) na etapa de fluxo."],
      },
      derivative_detector: {
        what: "Detecta crescimento no sinal analisando a derivada e retorna has_growth.",
        when: ["Alternativa ao detector por amplitude, dependendo do perfil do sinal."],
        how: ["Conecte sensor_data e use has_growth (booleano) na etapa de fluxo."],
      },
      ratio_detector: {
        what: "Detecta crescimento usando razoes entre canais/metricas e retorna has_growth.",
        when: ["Quando o criterio depende de comparacao entre canais."],
        how: ["Conecte sensor_data e use has_growth (booleano) na etapa de fluxo."],
      },
      features_merge: {
        what: "Combina multiplas saidas de features em um unico objeto de features.",
        when: [
          "Quando voce usa features estatisticas/temporais/forma/crescimento em paralelo.",
          "Antes de inferencia ML.",
        ],
        how: [
          "Conecte as entradas features_*.",
          "Escolha o modo (flat ou grouped) quando aplicavel.",
        ],
      },
      ml_inference: {
        what: "Executa um modelo ML para gerar uma predicao (value) e unidade (unit) quando configurado.",
        when: ["Para transformar features em uma predicao final por fluxo."],
        how: ["Conecte features e selecione o arquivo/modelo conforme configuracao do bloco."],
      },
      ml_inference_series: {
        what: "Executa um modelo ML usando uma série temporal (sensor_data) como entrada.",
        when: [
          "Quando o modelo espera o sinal (ou parte dele) em vez de features agregadas.",
          "Para modelos de classificação/regressão baseados na forma do sinal.",
        ],
        how: [
          "Conecte sensor_data (ex: após Extração + Selecionar janela + filtros).",
          "Selecione o canal (ou deixe vazio para usar o primeiro).",
          "Configure o layout esperado pelo modelo e o tamanho máximo (pad/trunc).",
          "Use a saída prediction em um bloco de resposta.",
        ],
        tips: [
          "Use max_length para padronizar o tamanho da entrada (importante para ONNX).",
          "Se o seu modelo foi treinado com padding no início/fim, ajuste align.",
        ],
      },
      ml_inference_multichannel: {
        what: "Executa um modelo ML usando vários canais do sensor_data como entrada (multicanal).",
        when: [
          "Quando o modelo usa mais de um canal ao mesmo tempo (ex: f1+f2+clear).",
          "Para modelos que combinam informação espectral/óptica do sensor.",
        ],
        how: [
          "Conecte sensor_data.",
          "Informe os canais (separados por vírgula).",
          "Escolha o layout (tempo x canais ou canais x tempo) conforme o modelo.",
          "Use a saída prediction em um bloco de resposta.",
        ],
        tips: ["Mantenha a mesma ordem de canais usada no treinamento do modelo."],
      },
      ml_transform_series: {
        what: "Aplica um modelo ML e grava a saída como um novo canal dentro do sensor_data (transformação).",
        when: [
          "Quando o modelo retorna uma série (ou vetor) para ser usada por blocos posteriores.",
          "Para criar um canal derivado por ML e continuar processando o fluxo.",
        ],
        how: [
          "Conecte sensor_data e selecione o canal de entrada.",
          "Defina o nome do canal de saída (output_channel).",
          "Conecte a saída sensor_data em filtros/features/detectores subsequentes.",
        ],
      },
      ml_detector: {
        what: "Executa um modelo ML e gera um booleano detected a partir de score/threshold.",
        when: [
          "Quando você precisa transformar um score de ML em uma decisão (sim/não).",
          "Para usar com Portão condicional ou Ramificação condicional.",
        ],
        how: [
          "Conecte sensor_data e selecione o canal.",
          "Configure threshold e operador (>=, >, <=, <).",
          "Use detected como condição em blocos de fluxo.",
        ],
      },
      response_pack: {
        what: "Empacota uma resposta parcial por grupo/fluxo (label) para permitir selecao/merge de saidas.",
        when: ["Quando voce tem multiplos fluxos e quer unificar em uma saida unica no final."],
        how: ["Conecte os resultados do fluxo e garanta que a tag (label) esteja presente no contexto."],
      },
      response_merge: {
        what: "Seleciona a resposta ativa entre multiplas entradas (ex: por analysisId).",
        when: ["Quando apenas um grupo de analysisId estara ativo por execucao."],
        how: ["Conecte as respostas parciais e habilite falhar se mais de uma saida estiver ativa, se desejar."],
      },
      response_builder: {
        what: "Monta a resposta final que sera retornada pela API (agrupando por label quando configurado).",
        when: ["Ultimo bloco do pipeline (saida da API)."],
        how: ["Conecte os resultados finais de cada fluxo e configure agrupamento/mapeamentos se necessario."],
      },
    },
  },
  analysis: {
    title: "Analysis IDs",
    hint: "Clique para destacar um ou mais analysisIds no canvas.",
    notConfigured: "Nenhum analysisId configurado. Abra o bloco \"Verificar valor na lista\" (analysisId) e adicione os valores aceitos.",
    configure: "Configurar roteamento",
    clear: "Limpar",
    clearTitle: "Limpar seleção de analysisIds",
    toggleTitle: "Alternar destaque deste analysisId",
    badge: "analysisId: {id}",
    flowsCount: "{count} fluxos",
    flowsCountShort: "{count}",
  },
  configuration: {
    empty: "Clique em um bloco no canvas para configurar",
    featuresInputsLabel: "Entradas de features",
    responseInputsLabel: "Entradas",
    responseInputsHint: "Aumente ou reduza o número de entradas disponíveis (isso remove conexões para entradas removidas).",
    addInput: "Adicionar entrada",
    featuresMergeInputsHint: "Use essas entradas para conectar diferentes blocos de features ao merge.",
    valueInList: "Verificar valor na lista",
    valueInListHint: "Gera uma condicao (true/false) ao verificar se um valor pertence a uma lista.",
    allowedValues: "Valores aceitos",
    valueToAdd: "Valor para adicionar",
    invertMatch: "Inverter condicao (NOT IN)",
    caseSensitive: "Diferenciar maiusculas/minusculas",
    trimValues: "Remover espacos no inicio/fim",
    noValuesConfigured: "Nenhum valor configurado",
    valueInListConnectHint: "Conecte o valor (ex: analysisId) neste bloco e use condition no condition_branch.",
    selectedConnection: "Conexão selecionada",
    from: "De",
    to: "Para",
    output: "Saída",
    input: "Entrada",
    responsePack: "Saída do grupo",
    responsePackHint: "Empacota uma resposta parcial para um grupo/fluxo (usado antes do merge).",
    responseMerge: "Unir saídas",
    responseMergeHint: "Seleciona a resposta ativa entre múltiplas saídas parciais (ex: por analysisId).",
    errorTitle: "Erro",
    ioInputs: "{count} entradas",
    ioOutputs: "{count} saídas",
    dataSource: "Fonte de dados",
    useDemoExperiment: "Usar experimento de demonstração",
    debug: "Debug",
    outputMode: "Modo de saída",
    dataCleaning: "Limpeza de dados",
    timeCut: "Corte temporal",
    outlierDetection: "Detecção de outliers",
    movingAverage: "Média móvel",
    savgol: "Savitzky-Golay",
    medianFilter: "Filtro de mediana",
    lowpass: "Passa-baixa (Butterworth)",
    ema: "Média móvel exponencial",
    derivative: "Derivada",
    normalization: "Normalização",
    curveFit: "Ajuste de curva",
    bestFit: "Melhor ajuste",
    statisticalFeatures: "Features estatísticas",
    temporalFeatures: "Features temporais",
    shapeFeatures: "Features de forma",
    growthFeatures: "Features de crescimento",
    combineFeatures: "Combinar features",
    connectFeaturesTitle: "Conecte os blocos de features:",
    spectralConversion: "Conversão espectral",
    amplitudeDetector: "Detector de amplitude",
    derivativeDetector: "Detector de derivada",
    ratioDetector: "Detector de razão",
    booleanExtractor: "Extrator booleano",
    conditionalGate: "Portão condicional",
    andGate: "Porta AND",
    orGate: "Porta OR",
    notGate: "Porta NOT",
    conditionalBranch: "Ramificação condicional",
    inactiveOutputHint: "Blocos conectados à saída inativa serão pulados automaticamente",
    flowMerge: "Junção de fluxos",
    flowMergeHint: "Útil para convergir fluxos após um condition_branch",
    labelTag: "Label (tag)",
    positionLabel: "Posição",
    connectionsLabel: "Conexões",
    mlInference: "Inferência ML",
    mlInferenceSeries: "Inferência ML (série)",
    mlInferenceMultichannel: "Inferência ML (multicanal)",
    mlTransformSeries: "Transformar série (ML)",
    mlDetector: "Detector (ML)",
    mlSeriesHint: "Usa sensor_data como entrada (sinal ao longo do tempo) para gerar uma predição.",
    mlMultichannelHint: "Usa múltiplos canais do sensor_data como entrada para gerar uma predição.",
    mlTransformHint: "Aplica ML e grava a saída como um novo canal no sensor_data (transformação).",
    mlDetectorHint: "Gera detected (booleano) a partir de score e um threshold configurado.",
    sensorFusion: "Combinar sensores",
    sensorFusionHint: "Une múltiplas entradas de sensor_data em uma só, com seleção de canais por sensor e alinhamento temporal.",
    sensorFusionInputs: "Entradas de sensores",
    inputsCount: "{count} entradas",
    prefix: "Prefixo",
    prefixPlaceholder: "ex: turb, neph, fluor",
    sensorFusionChannelsPlaceholder: "ex: f1, f2, r (vazio = todos)",
    sensorFusionChannelsHint: "Se vazio, usa todos os canais disponíveis da entrada. Separe por vírgula.",
    availableChannels: "{count} canais detectados",
    allChannels: "Selecionar todos os canais",
    useSuggested: "Usar sugestão",
    noConnection: "Sem conexão",
    mergeMode: "Alinhamento temporal",
    mergeModes: {
      intersection: "Interseção (somente onde todos têm dados)",
      union: "União (preenche ausentes com padding)",
    },
    resampleStep: "Reamostragem",
    resampleStepPlaceholder: "ex: 1.0",
    resampleStepHint: "Opcional. Usa a mesma unidade do eixo X (timestamps).",
    modelPath: "Arquivo do modelo (.onnx)",
    scalerPath: "Arquivo do scaler (.joblib)",
    scalerOptionalHint: "Opcional: deixe vazio se o modelo não usa scaler.",
    channel: "Canal",
    channelPlaceholder: "vazio = primeiro disponível",
    channelHint: "Nome do canal dentro do sensor_data (ex: R, f1, clear).",
    channels: "Canais",
    channelsHint: "Separe por vírgula. Ex: f1, f2, clear",
    inputLayout: "Layout de entrada",
    maxLength: "Tamanho máximo",
    padValue: "Valor de padding",
    align: "Alinhamento",
    outputUnit: "Unidade de saída",
    outputUnitHint: "Se definida, esta unidade será incluída na resposta.",
    outputChannel: "Canal de saída",
    outputChannelHint: "Nome do canal que será criado/adicionado no sensor_data.",
    threshold: "Threshold",
    operator: "Operador",
    includeRawOutput: "Mostrar dados processados (JSON)",
    layouts: {
      sequence: "Sequência (1, T)",
      flat: "Vetor (1, T)",
      channelsFirst: "Canais primeiro (1, 1, T)",
      timeChannels: "Tempo x canais (1, T, C)",
      channelsTime: "Canais x tempo (1, C, T)",
    },
    alignOptions: {
      end: "Alinhar ao fim",
      start: "Alinhar ao início",
    },
    responseBuilder: "Construtor de resposta",
    staticFields: "Campos estáticos",
    groupByLabel: "Agrupamento por label",
    defaultsInfoTitle: "Padrões automáticos por sensor",
    openLabel: "Abrir configuração do bloco",
    labelColor: "Cor da etiqueta",
    labelColorHint: "Se definida, esta cor será aplicada ao fluxo inteiro criado por esta etiqueta.",
  },
  dialogs: {
    confirmDeleteTitle: "Confirmar exclusão",
    confirmDeleteMessage:
      "Tem certeza que deseja excluir o bloco {nodeId}? Esta ação removerá o bloco e suas conexões.",
  },
  results: {
    empty: "Execute uma simulação para ver os resultados",
    status: "Status",
    success: "Sucesso",
    failed: "Falhou",
    duration: "Duração",
    errors: "Erros",
    stepsExecuted: "Passos executados",
    step: "Passo {label}",
    outputs: "Saídas",
    graphs: "Gráficos",
    availableKeys: "Chaves disponíveis: {keys}",
    enableDebugHint: "Ative as opções de debug no bloco para ver o JSON aqui.",
    showFullOutput: "Mostrar saída completa",
    hideFullOutput: "Ocultar saída completa",
    jsonSuffix: "(JSON)",
  },
  flows: {
    none: "Sem etiqueta",
    groupTitle: "Fluxo: {label}",
  },
  handles: {
    common: {
      data: "Dados",
      condition: "Condição",
    },
    detectors: {
      hasGrowth: "Crescimento",
    },
    conditionBranch: {
      true: "Se verdadeiro",
      false: "Se falso",
    },
    valueInList: {
      value: "Valor",
    },
    sensorFusion: {
      sensor: "Sensor {index}",
    },
  },
  options: {
    trueCondition: "TRUE (condição verdadeira)",
    falseCondition: "FALSE (condição falsa)",
  },
};
